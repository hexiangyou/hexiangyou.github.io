<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>centos7.9安装nvidia驱动和cuda</title>
    <link href="/2025/08/08/centos7-9%E5%AE%89%E8%A3%85nvidia%E9%A9%B1%E5%8A%A8%E5%92%8Ccuda/"/>
    <url>/2025/08/08/centos7-9%E5%AE%89%E8%A3%85nvidia%E9%A9%B1%E5%8A%A8%E5%92%8Ccuda/</url>
    
    <content type="html"><![CDATA[<h1 id="centos7-9离线安装nvidia驱动和cuda"><a href="#centos7-9离线安装nvidia驱动和cuda" class="headerlink" title="centos7.9离线安装nvidia驱动和cuda"></a>centos7.9离线安装nvidia驱动和cuda</h1><h2 id="安装nvidia驱动"><a href="#安装nvidia驱动" class="headerlink" title="安装nvidia驱动"></a>安装nvidia驱动</h2><p>系统和驱动信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">(base) [ghips@cugsat12 ~ 18:20:30]<span class="hljs-variable">$cat</span> /etc/centos-release<br>CentOS Linux release 7.9.2009 (Core)<br>(base) [ghips@cugsat12 ~ 18:31:43]<span class="hljs-variable">$uname</span> -r<br>3.10.0-1160.el7.x86_64<br>(base) [ghips@cugsat12 ~ 18:33:30]<span class="hljs-variable">$lspci</span> |grep -i nvidia<br>af:00.0 VGA compatible controller: NVIDIA Corporation Device 2204 (rev a1)<br>af:00.1 Audio device: NVIDIA Corporation Device 1aef (rev a1)<br></code></pre></td></tr></table></figure><p>显卡设备 <code>2204</code> 对应 RTX 3090</p><h3 id="1-下载兼容驱动："><a href="#1-下载兼容驱动：" class="headerlink" title="1. 下载兼容驱动："></a>1. 下载兼容驱动：</h3><p><strong>下载兼容驱动</strong>：</p><ul><li><p>访问 <a href="https://www.nvidia.cn/Download/Find.aspx?lang=cn">NVIDIA 驱动存档</a></p></li><li><p>选择：</p><ul><li>产品类型：GeForce</li><li>产品系列：GeForce RTX 30 Series</li><li>操作系统：Linux 64-bit</li><li>推荐版本：<strong>470.199.02</strong>（支持内核 3.10）</li></ul></li></ul><p>如果没找到：可直接使用链接下载：<a href="https://us.download.nvidia.com/XFree86/Linux-x86_64/470.199.02/NVIDIA-Linux-x86_64-470.199.02.run">https://us.download.nvidia.com/XFree86/Linux-x86_64/470.199.02/NVIDIA-Linux-x86_64-470.199.02.run</a></p><h3 id="2-安装依赖"><a href="#2-安装依赖" class="headerlink" title="2. 安装依赖"></a>2. 安装依赖</h3><p>   在联网机器上下载依赖</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">先安装 yum-utils（包含 yumdownloader）</span><br>yum install -y yum-utils<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 yumdownloader 下载所有指定包</span><br>yumdownloader --resolve --destdir=./offline-packages \<br>    kernel-devel-3.10.0-1160.el7.x86_64 \<br>    kernel-headers-3.10.0-1160.el7.x86_64 \<br>    gcc make elfutils-libelf-devel libglvnd-devel<br></code></pre></td></tr></table></figure><p>   将依赖文件拷贝到服务器</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装所有依赖</span><br>sudo yum localinstall ./offline-packages/*.rpm<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">遇到下述问题：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">处理依赖关系 libexpat.so.1()(64bit)，它被软件包 compat-exiv2-023-0.23-2.el7.x86_64 需要</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这是由于依赖冲突导致：具体来说，expat的更新版本需要替换现有的expat包，但是系统中已经安装的compat-exiv2-023包依赖于旧版本的expat</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">跳过冲突的包 单独安装</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建无冲突的安装目录</span><br>mkdir -p /root/nvidia-install/safe-packages<br><span class="hljs-meta prompt_"># </span><span class="language-bash">复制所有包（排除冲突的expat包）</span><br>find offline-packages/ -type f -name &quot;*.rpm&quot; ! -name &quot;expat-*&quot; -exec cp &#123;&#125; safe-packages/ \;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装筛选后的包</span><br>sudo yum localinstall ./safe-packages/*.rpm<br></code></pre></td></tr></table></figure><p>   如果上述方法行不通，可选择只安装最关键的核心依赖</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">只安装核心依赖</span><br>sudo rpm -ivh \<br>  kernel-devel-3.10.0-1160.el7.x86_64.rpm \<br>  gcc-4.8.5-44.el7.x86_64.rpm \<br>  make-3.82-24.el7.x86_64.rpm \<br>  elfutils-libelf-devel-0.176-5.el7.x86_64.rpm \<br>  --nodeps --force<br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查关键包</span><br>rpm -q kernel-devel gcc make elfutils-libelf-devel<br><span class="hljs-meta prompt_"># </span><span class="language-bash">手动安装缺失的包 例如缺失elfutils-libelf-devel</span><br>cd ~/software/nvidia-install/offline-packages<br>sudo rpm -ivh elfutils-libelf-devel-*.x86_64.rpm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">但是elfutils-libelf-devel 需要 pkgconfig(zlib) 依赖</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">所以首先安装zlib 相关依赖</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 zlib-devel</span><br>sudo rpm -ivh zlib-devel-1.2.7-21.el7_9.x86_64.rpm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 zlib (i686 架构)</span><br>sudo rpm -ivh zlib-1.2.7-21.el7_9.i686.rpm --nodeps<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 zlib-devel</span><br>sudo rpm -ivh zlib-devel-1.2.7-21.el7_9.x86_64.rpm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 zlib (i686 架构)</span><br>sudo rpm -ivh zlib-1.2.7-21.el7_9.i686.rpm --nodeps<br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后安装elfutils-libelf-devel</span> <br>sudo rpm -ivh elfutils-libelf-devel-0.176-5.el7.x86_64.rpm<br></code></pre></td></tr></table></figure><h3 id="3-安装兼容驱动"><a href="#3-安装兼容驱动" class="headerlink" title="3. 安装兼容驱动"></a>3. 安装兼容驱动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 确保在文本模式</span><br><span class="hljs-built_in">sudo</span> systemctl isolate multi-user.target<br><span class="hljs-comment"># 2. 禁用 nouveau（linux的开源 NVIDIA 显卡驱动）</span><br><span class="hljs-comment"># 创建一个黑名单配置文件，阻止 nouveau 驱动模块被加载。</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/modprobe.d/blacklist-nouveau.conf &lt;&lt;&lt; <span class="hljs-string">&quot;blacklist nouveau&quot;</span><br><span class="hljs-comment"># 备份当前内核的初始化内存文件系统（initramfs）</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mv</span> /boot/initramfs-$(<span class="hljs-built_in">uname</span> -r).img&#123;,.bak&#125;<br><span class="hljs-comment"># 重新生成初始化内存文件系统（initramfs）</span><br><span class="hljs-built_in">sudo</span> dracut -f /boot/initramfs-$(<span class="hljs-built_in">uname</span> -r).img $(<span class="hljs-built_in">uname</span> -r)<br><span class="hljs-comment"># 3. 安装驱动</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> +x NVIDIA-Linux-x86_64-470.199.02.run<br><span class="hljs-built_in">sudo</span> ./NVIDIA-Linux-x86_64-470.199.02.run<br></code></pre></td></tr></table></figure><p>安装过程会出现下述选项问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.Install NVIDIA&#x27;s 32-bit compatibility libraries? （安装32位兼容库？）                                                        <br>                                                                                                                       <br>                Yes                                    No<br>                选择NO（系统是64位）<br>2.Would you like to run the nvidia-xconfig utility to automatically update your X configuration file so that the       <br>  NVIDIA X driver will be used when you restart X?  Any pre-existing X configuration file will be backed up. （是否要运行nvidia-xconfig工具来自动更新X配置文件）<br>  选择YES（自动更新 X 配置，确保系统使用 NVIDIA 驱动）                        <br></code></pre></td></tr></table></figure><h3 id="4-验证安装"><a href="#4-验证安装" class="headerlink" title="4. 验证安装"></a>4. 验证安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment"># 加载核心模块</span><br>(base) [ghips@cugsat12 ~ 10:25:44]<span class="hljs-variable">$modprobe</span> nvidia<br><span class="hljs-comment"># 检查 NVIDIA 相关的内核模块是否已成功加载</span><br>(base) [ghips@cugsat12 ~ 10:25:51]<span class="hljs-variable">$lsmod</span> | grep nvidia<br>nvidia_drm             53197  0 <br>nvidia_modeset       1195581  1 nvidia_drm<br>nvidia              35441524  1 nvidia_modeset<br>drm_kms_helper        186531  3 mgag200,nouveau,nvidia_drm<br>drm                   456166  7 ttm,drm_kms_helper,mgag200,nvidia,nouveau,nvidia_drm<br><br>(base) [ghips@cugsat12 ~ 10:25:51]$ nvidia-smi<br><span class="hljs-comment">#成功输出显示</span><br>+-----------------------------------------------------------------------------+<br>| NVIDIA-SMI 470.199.02   Driver Version: 470.199.02   CUDA Version: 11.4     |<br>|-------------------------------+----------------------+----------------------+<br>| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |<br>| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |<br>|===============================+======================+======================|<br>|   0  NVIDIA RTX 3090     Off  | 00000000:AF:00.0 Off |                  N/A |<br>| 23%   38C    P8    15W / 350W |      0MiB / 24576MiB |      0%      Default |<br>+-------------------------------+----------------------+----------------------+<br></code></pre></td></tr></table></figure><h2 id="安装cuda"><a href="#安装cuda" class="headerlink" title="安装cuda"></a>安装cuda</h2><p>介绍：CUDA 的本质是<strong>NVIDIA GPU 的 “编程语言和工具集”</strong>，它让 GPU 从单纯的图形渲染设备升级为通用计算平台，极大地推动了需要大规模并行计算的领域的发展。</p><h4 id="1-下载离线安装包"><a href="#1-下载离线安装包" class="headerlink" title="1. 下载离线安装包"></a>1. 下载离线安装包</h4><p>访问 <a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA Toolkit 存档</a>：</p><ul><li>选择 CUDA 11.3.0（与我的驱动 470.199.02 兼容）</li><li>下载类型：<strong>runfile (local)</strong></li><li>文件名：<code>cuda_11.3.0_465.19.01_linux.run</code></li><li>下载链接：<a href="https://developer.download.nvidia.com/compute/cuda/11.3.0/local_installers/cuda_11.3.0_465.19.01_linux.run">https://developer.download.nvidia.com/compute/cuda/11.3.0/local_installers/cuda_11.3.0_465.19.01_linux.run</a></li></ul> <p>因为从网上得知CUDA11.4版本比较特殊的版本，可以用CUDA11.3版本替代（下载pytorch的时候会方便一些）</p><h4 id="2-准备依赖包（在可联网机器上操作，如果依赖已经存在则跳过此步骤）"><a href="#2-准备依赖包（在可联网机器上操作，如果依赖已经存在则跳过此步骤）" class="headerlink" title="2. 准备依赖包（在可联网机器上操作，如果依赖已经存在则跳过此步骤）"></a>2. 准备依赖包（在可联网机器上操作，如果依赖已经存在则跳过此步骤）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> cuda-offline-deps<br>yumdownloader --resolve --destdir=./cuda-offline-deps \<br>    mesa-libGLU \<br>    freeglut \<br>    libX11-devel \<br>    libXmu-devel \<br>    libXi-devel \<br>    libXext-devel \<br>    libXrender-devel \<br>    libXfixes-devel \<br>    gcc-c++<br><span class="hljs-comment"># 如果碰到问题，可参照上述安装nvidia依赖的处理方法</span><br></code></pre></td></tr></table></figure><h4 id="3-上传到服务器"><a href="#3-上传到服务器" class="headerlink" title="3. 上传到服务器"></a>3. 上传到服务器</h4><p>将以下文件上传到服务器：</p><ul><li><code>cuda_11.3.0_465.19.01_linux.run</code></li><li><code>cuda-offline-deps/</code> 目录所有 RPM 包</li></ul><h4 id="4-安装依赖（如果依赖已经存在可跳过）"><a href="#4-安装依赖（如果依赖已经存在可跳过）" class="headerlink" title="4. 安装依赖（如果依赖已经存在可跳过）"></a>4. 安装依赖（如果依赖已经存在可跳过）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum localinstall ./cuda-offline-deps/*.rpm<br></code></pre></td></tr></table></figure><h4 id="5-安装-CUDA"><a href="#5-安装-CUDA" class="headerlink" title="5. 安装 CUDA"></a>5. 安装 CUDA</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> sh cuda_11.3.0_465.19.01_linux.run \<br>    --silent \<br>    --toolkit \<br>    --samples \<br>    --override \<br>    --no-opengl-libs \<br>    --no-man-page \<br>    --no-drm \<br></code></pre></td></tr></table></figure><blockquote><p><strong>重要参数说明</strong>：</p><ul><li><code>--silent</code>：静默安装</li><li><code>--toolkit</code>：仅安装工具包</li><li><code>-- samples</code>：安装cuda的示例程序，用于验证cuda是否正常工作</li><li><code>--no-opengl-libs</code>：不安装 OpenGL 库（避免冲突）</li><li><code>--no-man-page</code>:不安装 CUDA 的手册页（man page），减少磁盘占用</li><li><code>--no-drm</code>:不安装 NVIDIA DRM 内核模块（<code>nvidia-drm</code>），该模块主要用于桌面环境的图形渲染，服务器或纯计算场景可禁用</li><li><code>--override</code>：忽略驱动版本检查,忽略一些非致命性的兼容性警告</li></ul></blockquote><h4 id="6-配置环境变量"><a href="#6-配置环境变量" class="headerlink" title="6. 配置环境变量"></a>6. 配置环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#  加载配置文件</span><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n# CUDA 11.3&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> -a /etc/profile<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export PATH=/usr/local/cuda-11.3/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;&#x27;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> -a /etc/profile<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export LD_LIBRARY_PATH=/usr/local/cuda-11.3/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;&#x27;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> -a /etc/profile<br><span class="hljs-built_in">source</span> /etc/profile<br><br><span class="hljs-comment">#  创建软链接（可选但推荐）</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -sf /usr/local/cuda-11.3 /usr/local/cuda<br></code></pre></td></tr></table></figure><h4 id="7-验证安装"><a href="#7-验证安装" class="headerlink" title="7. 验证安装"></a>7. 验证安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 检查编译器版本</span><br>nvcc --version<br><span class="hljs-comment"># 应显示：Cuda compilation tools, release 11.3, V11.3.109</span><br><br><span class="hljs-comment"># 2. 运行设备查询</span><br><span class="hljs-built_in">cd</span> ~<br>cuda-install-samples-11.3.sh .<br><span class="hljs-built_in">cd</span> NVIDIA_CUDA-11.3_Samples/1_Utilities/deviceQuery<br>make &amp;&amp; ./deviceQuery<br><br><span class="hljs-comment"># 成功输出：Result = PASS</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>centos</tag>
      
      <tag>nvidia</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos in vmware实现扩容</title>
    <link href="/2025/08/07/centos-in-vmware%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%AE%B9/"/>
    <url>/2025/08/07/centos-in-vmware%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hadoop03 ~]# fdisk -l<br>Disk /dev/sda: 107.4 GB, 107374182400 bytes, 209715200 sectors<br>Units = sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disk label type: dos<br>Disk identifier: 0x000aadaf<br><br>   Device Boot      Start         End      Blocks   Id  System<br>/dev/sda1   *        2048      616447      307200   83  Linux<br>/dev/sda2          616448     1665023      524288   82  Linux swap / Solaris<br>/dev/sda3         1665024    83886079    41110528   83  Linux<br><br>[root@hadoop03 ~]# df -h<br>Filesystem      Size  Used Avail Use% Mounted on<br>/dev/sda3        40G   18G   22G  45% /<br>devtmpfs        1.9G     0  1.9G   0% /dev<br>tmpfs           1.9G     0  1.9G   0% /dev/shm<br>tmpfs           1.9G   12M  1.9G   1% /run<br>tmpfs           1.9G     0  1.9G   0% /sys/fs/cgroup<br>/dev/sda1       297M  121M  177M  41% /boot<br></code></pre></td></tr></table></figure><p><strong>注：上述内容显示我最后一个分区类型为Linux，如果为Linux LVM，推荐参考：<a href="https://blog.csdn.net/hualinger/article/details/121553556">https://blog.csdn.net/hualinger/article/details/121553556</a></strong></p><p>上述内容显示虽然物理内存已经扩大到107.4GB，但是实际操作系统能够使用到的分区大小只有41.1GB。</p><p><strong>原因分析：</strong></p><ol><li><strong><code>fdisk -l</code> 输出解读：</strong><ul><li><code>Disk /dev/sda: 107.4 GB, 107374182400 bytes, 209715200 sectors</code> 明确显示了 <code>/dev/sda</code> 这块硬盘的总容量是 107.4 GB。</li><li>下面的 <code>/dev/sda1</code>, <code>/dev/sda2</code>, <code>/dev/sda3</code> 是这块硬盘上的分区。</li></ul></li><li><strong>VMware 操作：</strong><ul><li>在 VMware 中扩大了虚拟机的硬盘空间。这个操作的对象是虚拟机配置中指定的那个<strong>虚拟硬盘</strong>。</li><li>在 Linux 客户机内部，这个虚拟硬盘<strong>通常</strong>就被识别为 <code>/dev/sda</code>（尤其是当它只有一个硬盘时，几乎总是 <code>sda</code>）。</li></ul></li></ol><p><strong>重要说明：虽然扩大了 <code>/dev/sda</code> 的底层物理空间，但操作系统目前还没有使用这些新空间！</strong></p><ul><li><strong><code>fdisk -l</code> 显示的是操作系统 *当前识别到* 的磁盘大小，而不是底层物理磁盘的 *实际最大* 大小。</strong> 运行 <code>fdisk -l</code> 的结果显示 <code>/dev/sda</code> 仍然是 107.4GB，这说明：<ol><li><strong>内核尚未感知到磁盘大小变化：</strong> 需要通知内核重新读取磁盘的分区表信息。</li><li><strong>现有分区未扩展：</strong> <code>/dev/sda3</code> 分区（看起来是主数据分区）仍然只占据了原来那 41.1GB 的空间。新增加的空间目前是硬盘上 <code>/dev/sda3</code> 分区之后未分配的空白区域。</li></ol></li></ul><p>使用下述方法对将未分配空间加载到已有的分区上：</p><h2 id="扩容方法（内核重新扫描-扩展分区-扩展文件系统）"><a href="#扩容方法（内核重新扫描-扩展分区-扩展文件系统）" class="headerlink" title="扩容方法（内核重新扫描 -&gt; 扩展分区 -&gt; 扩展文件系统）"></a>扩容方法（<strong>内核重新扫描 -&gt; 扩展分区 -&gt; 扩展文件系统</strong>）</h2><ol><li><p><strong>通知内核磁盘大小已更改：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> 1 &gt; /sys/class/block/sda/device/rescan<br></code></pre></td></tr></table></figure><ul><li>这条命令告诉内核重新扫描 <code>/dev/sda</code> 设备，使其检测到新的物理大小。<strong>执行后再次运行 <code>fdisk -l</code>，应该能看到 <code>/dev/sda</code> 的总容量变大了。</strong></li></ul></li><li><p><strong>扩展分区表以占用新空间：</strong></p><ul><li><p>需要修改分区表，将新增加的空间分配到现有分区（通常是最后一个分区 <code>/dev/sda3</code>）或者创建一个新分区。</p></li><li><p><strong>最常见做法是扩展最后一个分区 (<code>/dev/sda3</code>):</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk /dev/sda<br></code></pre></td></tr></table></figure><ul><li>在 <code>fdisk</code> 交互提示符下：<ul><li>输入 <code>p</code> 打印当前分区表（确认信息）。</li><li>输入 <code>d</code> 删除分区。<strong>输入分区号 <code>3</code><strong>（删除 <code>/dev/sda3</code>）。</strong>别担心，只要不写入，操作还在内存中。</strong></li><li>输入 <code>n</code> 创建新分区。<ul><li>选择 <code>p</code> (主分区)。</li><li>输入分区号 <code>3</code> (和原来一样)。</li><li>输入<strong>起始扇区</strong>：直接按回车，使用默认值（<strong>必须是原来 <code>/dev/sda3</code> 的起始扇区 <code>1665024</code>！</strong> 非常重要，不能改错！<code>fdisk</code> 通常会记住并建议这个值）。</li><li>输入<strong>结束扇区</strong>：直接按回车，使用默认值（<strong>默认会使用到磁盘末尾的所有可用空间</strong>，这正是我们想要的）。</li></ul></li><li>输入 <code>t</code> 设置分区类型。**输入分区号 <code>3</code>**。输入类型 <code>83</code> (Linux)。</li><li>输入 <code>p</code> 再次打印分区表，<strong>仔细检查</strong>新 <code>/dev/sda3</code> 的起始扇区是否和原来的 <code>1665024</code> <strong>完全一致</strong>，并且结束扇区已经扩展到接近磁盘末尾。</li><li><strong>确认无误后</strong>，输入 <code>w</code> 将新分区表写入磁盘并退出。</li></ul></li><li><strong>警告：</strong> 操作分区表有风险！务必确认起始扇区正确！错误操作可能导致数据丢失。<strong>强烈建议在操作前备份重要数据。</strong></li></ul></li><li><p>或者使用更简单的工具 <code>parted</code> (推荐)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">parted /dev/sda<br></code></pre></td></tr></table></figure><ul><li>在 <code>(parted)</code> 提示符下：<ul><li>输入 <code>print</code> 查看当前分区和磁盘信息。</li><li>输入 <code>resizepart 3 100%</code> (这表示将分区号 3 扩展到占用剩余 100% 的空间)。</li><li>输入 <code>print</code> 确认新分区大小。</li><li>输入 <code>quit</code> 退出。</li></ul></li></ul></li></ul></li><li><p><strong>通知内核分区表已更改：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">partprobe /dev/sda  <span class="hljs-comment"># 或者执行 `partx -u /dev/sda` 或 `reboot`</span><br></code></pre></td></tr></table></figure><ul><li>让内核重新读取分区表，识别到 <code>/dev/sda3</code> 的新大小。<code>partprobe</code> 或 <code>partx -u</code> 通常能立即生效，否则需要重启。</li></ul></li><li><p><strong>扩展文件系统以填充分区：</strong></p><ul><li><p>现在分区 <code>/dev/sda3</code> 变大了，但里面的文件系统（如 ext4）还没有扩展到新空间。</p></li><li><p>假设 <code>/dev/sda3</code> 是 ext4 文件系统 (最常见)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">resize2fs /dev/sda3<br></code></pre></td></tr></table></figure></li><li><p>如果是 XFS 文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xfs_growfs /mountpoint/of/sda3  <span class="hljs-comment"># 替换为 `/dev/sda3` 的实际挂载点，例如 `/`</span><br></code></pre></td></tr></table></figure></li><li><p>这个命令会让文件系统扩展到填满整个 <code>/dev/sda3</code> 分区。</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>centos</tag>
      
      <tag>扩容</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot限流配置（Bucket4j）</title>
    <link href="/2025/07/31/springboot%E9%99%90%E6%B5%81%E9%85%8D%E7%BD%AE%EF%BC%88Bucket4j%EF%BC%89/"/>
    <url>/2025/07/31/springboot%E9%99%90%E6%B5%81%E9%85%8D%E7%BD%AE%EF%BC%88Bucket4j%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="使用Bucket4j对controller接口进行限流配置"><a href="#使用Bucket4j对controller接口进行限流配置" class="headerlink" title="使用Bucket4j对controller接口进行限流配置"></a>使用Bucket4j对controller接口进行限流配置</h2><p>步骤1：添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.vladimir-bukhtoyarov<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>bucket4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>只对一个接口单独限流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.github.bucket4j.*;<br><br><span class="hljs-keyword">import</span> java.time.Duration;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JudgeController</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Bucket bucket;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JudgeController</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 每10秒5个令牌；也即每10秒只能请求5次</span><br>        <span class="hljs-type">Bandwidth</span> <span class="hljs-variable">limit</span> <span class="hljs-operator">=</span> Bandwidth.classic(<span class="hljs-number">5</span>, Refill.intervally(<span class="hljs-number">5</span>, Duration.ofSeconds(<span class="hljs-number">10</span>)));<br>        <span class="hljs-built_in">this</span>.bucket = Bucket4j.builder().addLimit(limit).build();<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/submit&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> JudgeRequest request)</span> &#123;<br>        <span class="hljs-comment">// 消耗令牌</span><br>        <span class="hljs-keyword">if</span> (!bucket.tryConsume(<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">return</span> ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS)<br>                    .body(<span class="hljs-string">&quot;Rate limit exceeded. Try again later.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>().writeValueAsString(request);<br>            String[] cmd = &#123;<br>                    <span class="hljs-string">&quot;docker&quot;</span>, <span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-string">&quot;-i&quot;</span>, <span class="hljs-string">&quot;judge0-server-1&quot;</span>,<br>                    <span class="hljs-string">&quot;curl&quot;</span>, <span class="hljs-string">&quot;-s&quot;</span>, <span class="hljs-string">&quot;-X&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;http://localhost:2358/submissions?base64_encoded=false&amp;wait=true&quot;</span>,<br>                    <span class="hljs-string">&quot;-H&quot;</span>, <span class="hljs-string">&quot;Content-Type: application/json&quot;</span>,<br>                    <span class="hljs-string">&quot;-d&quot;</span>, json<br>            &#125;;<br>            <span class="hljs-keyword">return</span> runCommand(cmd);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)<br>                    .body(<span class="hljs-string">&quot;Error building submission: &quot;</span> + e.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>测试限流功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRateLimiting</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000</span>; i++) &#123;<br>        <span class="hljs-type">HttpHeaders</span> <span class="hljs-variable">headers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeaders</span>();<br>        headers.setContentType(MediaType.APPLICATION_JSON);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;source_code\&quot;:\&quot;print(1)\&quot;,\&quot;language_id\&quot;:71&#125;&quot;</span>;<br>        HttpEntity&lt;String&gt; request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpEntity</span>&lt;&gt;(body, headers);<br>        <span class="hljs-keyword">try</span>&#123;<br>            ResponseEntity&lt;String&gt; response = restTemplate.postForEntity(<span class="hljs-string">&quot;http://localhost:8083/api/v1/admin/judge/submit&quot;</span>, request, String.class);<br>            System.out.println(<span class="hljs-string">&quot;Request &quot;</span> + i + <span class="hljs-string">&quot; → Status: &quot;</span> + response.getStatusCode());<br>        &#125;<span class="hljs-keyword">catch</span> (HttpClientErrorException.TooManyRequests e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Request &quot;</span> + i + <span class="hljs-string">&quot; → Status: 429 Too Many Requests&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <strong>Bucket4j</strong> 对 <strong>不同 API 路径</strong> 进行 <strong>单独限流</strong>：（创建限流过滤器）<br>Spring Boot 会自动把这个 <code>Filter</code> 注册到整个 Web 请求处理链中。因此，**每一个 HTTP 请求在进入 Controller 之前，都会经过这个 <code>Filter</code>**。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.github.bucket4j.Bandwidth;<br><span class="hljs-keyword">import</span> io.github.bucket4j.Bucket;<br><span class="hljs-keyword">import</span> io.github.bucket4j.Refill;<br><span class="hljs-keyword">import</span> jakarta.servlet.*;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.time.Duration;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimitFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br><br>    <span class="hljs-comment">// 保存每个路径的限流桶</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Bucket&gt; buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span><br>            <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br><br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> (HttpServletRequest) request;<br>        <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">httpResponse</span> <span class="hljs-operator">=</span> (HttpServletResponse) response;<br><span class="hljs-comment">// 获取请求的URI</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> httpRequest.getRequestURI();<br><br>        <span class="hljs-comment">// 获取对应路径的限流 Bucket；确保第一次访问某个路径时会创建一个限流桶，以后复用。</span><br>        <span class="hljs-type">Bucket</span> <span class="hljs-variable">bucket</span> <span class="hljs-operator">=</span> buckets.computeIfAbsent(path, <span class="hljs-built_in">this</span>::createBucketForPath);<br><span class="hljs-comment">//尝试消耗一个令牌</span><br>        <span class="hljs-keyword">if</span> (bucket.tryConsume(<span class="hljs-number">1</span>)) &#123;<br>            chain.doFilter(request, response); <span class="hljs-comment">// 放行请求</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            httpResponse.setStatus(<span class="hljs-number">429</span>); <span class="hljs-comment">// Too Many Requests</span><br>            httpResponse.getWriter().write(<span class="hljs-string">&quot;Rate limit exceeded for path: &quot;</span> + path);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Bucket <span class="hljs-title function_">createBucketForPath</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-comment">// 为不同路径设置不同的限流策略</span><br>        <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/languages&quot;</span>)) &#123;<br>            <span class="hljs-comment">// /languages：10秒最多5次</span><br>            <span class="hljs-keyword">return</span> Bucket.builder()<br>                    .addLimit(Bandwidth.classic(<span class="hljs-number">5</span>, Refill.intervally(<span class="hljs-number">5</span>, Duration.ofSeconds(<span class="hljs-number">10</span>))))<br>                    .build();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/submit&quot;</span>)) &#123;<br>            <span class="hljs-comment">// /submit：10秒最多2次</span><br>            <span class="hljs-keyword">return</span> Bucket.builder()<br>                    .addLimit(Bandwidth.classic(<span class="hljs-number">2</span>, Refill.intervally(<span class="hljs-number">2</span>, Duration.ofSeconds(<span class="hljs-number">10</span>))))<br>                    .build();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 默认：10秒最多20次</span><br>            <span class="hljs-keyword">return</span> Bucket.builder()<br>                    .addLimit(Bandwidth.classic(<span class="hljs-number">20</span>, Refill.intervally(<span class="hljs-number">20</span>, Duration.ofSeconds(<span class="hljs-number">10</span>))))<br>                    .build();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>此时在controller中就不需要多余的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Judge0Controller</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/languages&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title function_">getLanguages</span><span class="hljs-params">()</span> &#123;<br>        String[] cmd = &#123;<br>                <span class="hljs-string">&quot;docker&quot;</span>, <span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-string">&quot;judge0-server-1&quot;</span>,<br>                <span class="hljs-string">&quot;curl&quot;</span>, <span class="hljs-string">&quot;-s&quot;</span>, <span class="hljs-string">&quot;http://localhost:2358/languages&quot;</span><br>        &#125;;<br>        <span class="hljs-keyword">return</span> runCommand(cmd);<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/submit&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title function_">submitCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ResponseEntity.ok(<span class="hljs-string">&quot;Submit endpoint accessed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/ping&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title function_">ping</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ResponseEntity.ok(<span class="hljs-string">&quot;pong&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ResponseEntity&lt;String&gt; <span class="hljs-title function_">runCommand</span><span class="hljs-params">(String[] cmd)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessBuilder</span>(cmd).start();<br>            process.waitFor();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(process.getInputStream().readAllBytes());<br>            <span class="hljs-keyword">return</span> ResponseEntity.ok(output);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)<br>                    .body(<span class="hljs-string">&quot;Command execution failed: &quot;</span> + e.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试接口：（<strong>使用线程池</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLanguagesRateLimiting</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">requestCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">successCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">tooManyRequestsCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//用于等待所有任务完成的同步工具</span><br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(requestCount);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= requestCount; i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">requestNumber</span> <span class="hljs-operator">=</span> i;<br>        executor.submit(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(<br>                    <span class="hljs-string">&quot;http://localhost:8083/api/v1/admin/judge/languages&quot;</span>, <br>                    String.class<br>                );<br>                <br>                <span class="hljs-type">int</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> response.getStatusCodeValue();<br>                System.out.println(<span class="hljs-string">&quot;Request &quot;</span> + requestNumber + <span class="hljs-string">&quot; → Status: &quot;</span> + statusCode);<br>                <br>                <span class="hljs-keyword">if</span> (statusCode == <span class="hljs-number">200</span>) &#123;<br>                    successCount.incrementAndGet();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (HttpClientErrorException.TooManyRequests e) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Request &quot;</span> + requestNumber + <span class="hljs-string">&quot; → Status: 429 Too Many Requests&quot;</span>);<br>                tooManyRequestsCount.incrementAndGet();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                System.err.println(<span class="hljs-string">&quot;Request &quot;</span> + requestNumber + <span class="hljs-string">&quot; failed: &quot;</span> + e.getMessage());<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                latch.countDown();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//主线程（执行测试方法的线程）会阻塞在这里，直到latch的计数器减到 0</span><br>        latch.await();<br>        executor.shutdown();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        Thread.currentThread().interrupt();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;Total requests: &quot;</span> + requestCount);<br>    System.out.println(<span class="hljs-string">&quot;Successful requests: &quot;</span> + successCount.get());<br>    System.out.println(<span class="hljs-string">&quot;Too Many Requests (429): &quot;</span> + tooManyRequestsCount.get());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>springboot</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离线部署docker and judge0日志</title>
    <link href="/2025/07/27/%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2docker-and-judge0%E6%97%A5%E5%BF%97/"/>
    <url>/2025/07/27/%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2docker-and-judge0%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="离线部署docker"><a href="#离线部署docker" class="headerlink" title="离线部署docker"></a>离线部署docker</h2><p>首先下载离线安装包：<a href="https://download.docker.com/linux/static/stable/">https://download.docker.com/linux/static/stable/</a></p><p>将安装包拷贝到目标服务器上</p><p>在主机上解压文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -xvzf docker-26.1.4.tgz<br><span class="hljs-meta prompt_">#</span><span class="language-bash">解压完之后的文件会放到当前目录中的docker目录中</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">递归的赋予docker目录中文件可执行权限</span><br>sudo chmod 755 -R docker <br>sudo cp docker/* /usr/bin/<br></code></pre></td></tr></table></figure><p>配置docker服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit]<br>Description=Docker Application Container Engine<br>Documentation=https://docs.docker.com<br>After=network-online.target firewalld.service<br>Wants=network-online.target<br>  <br>[Service]<br>Type=notify<br><span class="hljs-meta prompt_"># </span><span class="language-bash">the default is not to use systemd <span class="hljs-keyword">for</span> cgroups because the delegate issues still</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">exists and systemd currently does not support the cgroup feature <span class="hljs-built_in">set</span> required</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> containers run by docker</span><br>ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock --selinux-enabled=false --default-ulimit nofile=65536:65536<br>ExecReload=/bin/kill -s HUP $MAINPID<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Having non-zero Limit*s causes performance problems due to accounting overhead</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">in</span> the kernel. We recommend using cgroups to <span class="hljs-keyword">do</span> container-local accounting.</span><br>LimitNOFILE=infinity<br>LimitNPROC=infinity<br>LimitCORE=infinity<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Uncomment TasksMax <span class="hljs-keyword">if</span> your systemd version supports it.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Only systemd 226 and above support this version.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">TasksMax=infinity</span><br>TimeoutStartSec=0<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">set</span> delegate <span class="hljs-built_in">yes</span> so that systemd does not reset the cgroups of docker containers</span><br>Delegate=yes<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">kill</span> only the docker process, not all processes <span class="hljs-keyword">in</span> the cgroup</span><br>KillMode=process<br><span class="hljs-meta prompt_"># </span><span class="language-bash">restart the docker process <span class="hljs-keyword">if</span> it exits prematurely</span><br>Restart=on-failure<br>StartLimitBurst=3<br>StartLimitInterval=60s<br>  <br>[Install]<br>WantedBy=multi-user.target<br><br></code></pre></td></tr></table></figure><p>赋予docker服务配置文件docker.service执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chmod +x /etc/systemd/system/docker.service<br></code></pre></td></tr></table></figure><p>启动docker服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#加载systemctl配置</span><br><span class="hljs-built_in">sudo</span> systemctl daemon-reload<br><span class="hljs-comment">#设置开机自启动</span><br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> docker.service <br><span class="hljs-comment">#启动docker服务</span><br><span class="hljs-built_in">sudo</span> systemctl start docker <br><span class="hljs-comment">#检查docker状态</span><br><span class="hljs-built_in">sudo</span> systemctl status docker<br><span class="hljs-comment">#查看docker版本</span><br>docker -v<br></code></pre></td></tr></table></figure><p>自定义docker运行目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">配置docker服务自定义设置</span><br>sudo mkdir -p /etc/docker<br>sudo mkdir -p /data/app/dockerWork<br>sudo vim /etc/docker/daemon.json<br></code></pre></td></tr></table></figure><p>在文件中添加下述内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br>  &quot;data-root&quot;: &quot;/data/dockerData&quot;,#填入自己的目录<br>&#125;<br></code></pre></td></tr></table></figure><p>更改后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl daemon-reload<br>sudo systemctl restart docker <br>docker info #输出查看Root Dir<br></code></pre></td></tr></table></figure><p>出现的问题：exec: “fuse-overlayfs”: executable file not found in $PATH</p><p>解决办法：安装fuse-overlayfs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">安装yun-utils</span><br>sudo yum install -y yum-utils<br><span class="hljs-meta prompt_">#</span><span class="language-bash">在联网的机器中下载rpm</span><br>mkdir -p /tmp/fuse-overlayfs &amp;&amp; cd /tmp/fuse-overlayfs<br>yumdownloader --resolve --destdir=. fuse-overlayfs<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将下载好的包拷贝到目标服务器，并在目录下执行</span><br>sudo rpm -Uvh --force *.rpm<br><span class="hljs-meta prompt_">#</span><span class="language-bash">验证安装</span><br>fuse-overlayfs --version<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">过程可能出现错误：依赖检测失败：</span><br>libfuse3.so.3()(64bit) 被 fuse-overlayfs-0.7.2-6.el7_8.x86_64 需要<br>libfuse3.so.3(FUSE_3.0)(64bit) 被 fuse-overlayfs-0.7.2-6.el7_8.x86_64 需要<br>libfuse3.so.3(FUSE_3.2)(64bit) 被 fuse-overlayfs-0.7.2-6.el7_8.x86_64 需要<br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用下述命令继续下载缺失包</span><br>yumdownloader --resolve fuse3 fuse3-libs<br><br></code></pre></td></tr></table></figure><p>离线安装docker compose</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">下载安装包</span><br>https://github.com/docker/compose/releases<br><span class="hljs-meta prompt_">#</span><span class="language-bash">或者</span><br>wget https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-linux-x86_64<br><span class="hljs-meta prompt_">#</span><span class="language-bash">复制到离线服务器上</span><br>chmod +x docker-compose-linux-x86_64<br>mv docker-compose-linux-x86_64 docker-compose<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将文件放到Docker CLI插件默认目录中</span><br>mkdir -p ~/.docker/cli-plugins<br>mv docker-compose ~/.docker/cli-plugins/docker-compose<br>chmod +x ~/.docker/cli-plugins/docker-compose<br><span class="hljs-meta prompt_">#</span><span class="language-bash">或者放到系统级插件目录</span><br>sudo mkdir -p /usr/local/lib/docker/cli-plugins<br>sudo mv docker-compose /usr/local/lib/docker/cli-plugins/docker-compose<br>sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose<br><span class="hljs-meta prompt_">#</span><span class="language-bash">验证安装</span><br>docker compose version<br><br></code></pre></td></tr></table></figure><p>部署docker出现问题：当前用户无法访问docker守护进程的Unix socker文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps -a<br>permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get &quot;http://%2Fvar%2Frun%2Fdocker.sock/v1.45/containers/json?all=1&quot;: dial unix /var/run/docker.sock: connect: permission denied <br></code></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看 socket 文件的权限：</span><br>ls -l /var/run/docker.sock<br><span class="hljs-meta prompt_">#</span><span class="language-bash">正常情况是</span><br>srw-rw---- 1 root docker 0 Jul 25 22:13 /var/run/docker.sock<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果组不是 docker，或没有 rw- 权限，执行：</span><br>sudo chown root:docker /var/run/docker.sock<br>sudo chmod 660 /var/run/docker.sock<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将当前用户添加到docker组</span><br>sudo groupadd docker<br>sudo usermod -aG docker $USER<br>newgrp docker<br></code></pre></td></tr></table></figure><h2 id="离线部署Judge"><a href="#离线部署Judge" class="headerlink" title="离线部署Judge"></a>离线部署Judge</h2><p>首先在联网机器上准备好judge0的镜像和代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">克隆judge0项目</span><br>git clone https://github.com/judge0/judge0.git<br>cd judge0<br><span class="hljs-meta prompt_">#</span><span class="language-bash">下载镜像</span><br>docker compose -f docker-compose.yml pull<br><span class="hljs-meta prompt_">#</span><span class="language-bash">导出镜像</span><br>docker save -o judge0_images.tar judge0/judge0:latest postgres:16.2 redis:7.2.4<br><span class="hljs-meta prompt_">#</span><span class="language-bash">拷贝镜像到离线机器 导入</span><br>docker load -i judge0_images.tar<br></code></pre></td></tr></table></figure><p>在judge目录中执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up -d<br></code></pre></td></tr></table></figure><p>然后就能看到启动的容器，不出意外的话就能访问judge0的api了</p><p>测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl http://localhost:2358/languages<br></code></pre></td></tr></table></figure><h2 id="部署遇到的问题"><a href="#部署遇到的问题" class="headerlink" title="部署遇到的问题"></a>部署遇到的问题</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ghips@cugsat11 DZ01]$ docker load -i judge0_images.tar<br>dd5242c2dc8a: Loading layer  119.2MB/119.2MB<br>6f1c84e6ec59: Loading layer  17.11MB/17.11MB<br>b52c1c103fae: Loading layer  17.85MB/17.85MB<br>e6d60910d056: Loading layer  149.9MB/149.9MB<br>f63773c65620: Loading layer  520.2MB/520.2MB<br>c8e492f75d96: Loading layer  502.4MB/502.4MB<br>c0b285f105a3: Loading layer  139.1MB/139.1MB<br>94f42f282973: Loading layer  355.6MB/355.6MB<br>a01174846de8: Loading layer  839.9MB/839.9MB<br>93ef8e607237: Loading layer  330.6MB/330.6MB<br>96bdb92d8d86: Loading layer  14.15MB/14.15MB<br>a977fbf9c987: Loading layer  225.9MB/225.9MB<br>74fd0441fe80: Loading layer  2.084GB/2.084GB<br>706af213e51e: Loading layer  669.6MB/669.6MB<br>2dc66f1cc28d: Loading layer  76.08MB/76.08MB<br>write /var/lib/docker/vfs/dir/c001c39b7e4fb4d7b256da603489645fb69c5da681836004af90e325c5c9bd22/usr/local/ghc-8.8.1/lib/ghc-8.8.1/Cabal-3.0.0.0/HSCabal-3.0.0.0.o: no space left on device<br></code></pre></td></tr></table></figure><p>上述没空间了，可以切换docker运行目录。</p><p>问题2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ghips@cugsat11 DZ01]$ sudo docker load -i judge0_images.tar<br>dd5242c2dc8a: Loading layer  119.2MB/119.2MB<br>6f1c84e6ec59: Loading layer  17.11MB/17.11MB<br>b52c1c103fae: Loading layer  17.85MB/17.85MB<br>e6d60910d056: Loading layer  149.9MB/149.9MB<br>f63773c65620: Loading layer  520.2MB/520.2MB<br>c8e492f75d96: Loading layer  502.4MB/502.4MB<br>c0b285f105a3: Loading layer  139.1MB/139.1MB<br>94f42f282973: Loading layer  355.6MB/355.6MB<br>a01174846de8: Loading layer  839.9MB/839.9MB<br>93ef8e607237: Loading layer  330.6MB/330.6MB<br>96bdb92d8d86: Loading layer  14.15MB/14.15MB<br>a977fbf9c987: Loading layer  225.9MB/225.9MB<br>74fd0441fe80: Loading layer  2.084GB/2.084GB<br>706af213e51e: Loading layer  669.6MB/669.6MB<br>2dc66f1cc28d: Loading layer  76.08MB/76.08MB<br>d4b5a090f908: Loading layer  138.3MB/138.3MB<br>6abc0d38bb19: Loading layer  9.417MB/9.417MB<br>c3cba357858f: Loading layer  354.5MB/354.5MB<br>1f8a2cdb429f: Loading layer  335.2MB/335.2MB<br>8e405162993d: Loading layer  40.47MB/40.47MB<br>ddc736983f7e: Loading layer  352.2MB/352.2MB<br>7265bf73ba48: Loading layer    152MB/152MB<br>363040cff96d: Loading layer  216.9MB/216.9MB<br>597b3b3b8563: Loading layer  434.7kB/434.7kB<br>8323279740f2: Loading layer  152.2MB/152.2MB<br>beb324aeeb51: Loading layer  2.868MB/2.868MB<br>19f87ad64a26: Loading layer  13.05MB/13.05MB<br>0e9bb4586e45: Loading layer  41.63MB/41.63MB<br>5fae1865d171: Loading layer  2.953MB/2.953MB<br>d85c09b6bff0: Loading layer  1.228GB/1.228GB<br>b040914a6c33: Loading layer  61.36MB/61.36MB<br>e546454d5a85: Loading layer  56.46MB/56.46MB<br>unlinkat /etc/logcheck/ignore.d.server: invalid argument<br></code></pre></td></tr></table></figure><p>将 Docker 存储驱动切换成 <code>vfs</code>可以解决上述问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&quot;storage-driver&quot;: &quot;vfs&quot;<br></code></pre></td></tr></table></figure><p>问题3：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ghips@cugsat11 judge0]$ curl http://localhost:2358/languages<br>curl: (56) Recv failure: Connection reset by peer<br></code></pre></td></tr></table></figure><p>这个问题暂时不知道如何解决，<strong>可能是系统内核版本太低</strong>又或者是其他问题。</p><p>但是我采取曲线救国策略，利用下述命令可以执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec judge0-server-1 curl http://localhost:2358/languages<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
      <category>在线IDE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&#39;模仿MYDB之路&#39;</title>
    <link href="/2025/07/11/%E6%A8%A1%E4%BB%BFMYDB%E4%B9%8B%E8%B7%AF/"/>
    <url>/2025/07/11/%E6%A8%A1%E4%BB%BFMYDB%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="模仿实现开源项目MYDB（01）"><a href="#模仿实现开源项目MYDB（01）" class="headerlink" title="模仿实现开源项目MYDB（01）"></a>模仿实现开源项目MYDB（01）</h2><h3 id="理解TM（Transaction-Manager）"><a href="#理解TM（Transaction-Manager）" class="headerlink" title="理解TM（Transaction  Manager）"></a>理解TM（Transaction  Manager）</h3><p>几个关键知识点：</p><ol><li><p><strong>事务：事务是数据库中一组操作的集合，要么全部执行成功，要么全部不执行，是不可分割的逻辑单位。</strong></p><table><thead><tr><th>特性</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td><strong>A</strong> 原子性（Atomicity）</td><td>事务中的所有操作要么全部执行，要么全部不执行</td><td>转账不能只扣钱不加钱</td></tr><tr><td><strong>C</strong> 一致性（Consistency）</td><td>执行事务前后，数据库处于一致状态</td><td>转账前后总金额不变</td></tr><tr><td><strong>I</strong> 隔离性（Isolation）</td><td>多个事务并发执行时，不应相互干扰</td><td>同时转账不会互相覆盖数据</td></tr><tr><td><strong>D</strong> 持久性（Durability）</td><td>事务一旦提交，对数据库的更改就是永久的，即使系统崩溃也不会丢失</td><td>转账成功后即使断电也不会丢失结果</td></tr></tbody></table></li></ol><h3 id="代码解释："><a href="#代码解释：" class="headerlink" title="代码解释："></a>代码解释：</h3><ul><li>检查XID文件是否合法（检查文件完整性）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkXIDCounter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">fileLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 获取 XID 文件的物理长度，如果读取失败或文件长度不足头部长度（LEN_XID_HEADER_LENGTH），则认为文件损坏。</span><br>    <span class="hljs-keyword">try</span> &#123;<br>            fileLen = file.length();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e1) &#123;<br>            Panic.panic(Error.BadXIDFileException);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fileLen &lt; LEN_XID_HEADER_LENGTH) &#123;<br>            Panic.panic(Error.BadXIDFileException);<br>        &#125;<br>    <span class="hljs-comment">//从文件头部读取 8 字节（long类型）作为当前事务计数器值，用于后续一致性校验。</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(LEN_XID_HEADER_LENGTH);<br>        <span class="hljs-keyword">try</span> &#123;<br>            fc.position(<span class="hljs-number">0</span>);<span class="hljs-comment">//设置文件起始处（文件头）</span><br>            fc.read(buf);<span class="hljs-comment">//从当前文件位置开始读取数据，一直读到缓冲区被填满</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            Panic.panic(e);<br>        &#125;<br>    <span class="hljs-comment">//getXidPosition(xid) 方法计算指定 XID 在文件中的位置（例如，每个事务状态占 8 字节，XID=1 的位置是 8，XID=2 的位置是 16...）。</span><br>        <span class="hljs-built_in">this</span>.xidCounter = Parser.parseLong(buf.array());<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> getXidPosition(<span class="hljs-built_in">this</span>.xidCounter + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(end != fileLen) &#123;<br>            Panic.panic(Error.BadXIDFileException);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>更新事务ID在文件中的状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateXID</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span> status)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getXidPosition(xid);<span class="hljs-comment">//计算xid在文件中的位置</span><br>    <span class="hljs-type">byte</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[XID_FIELD_SIZE];<br>    tmp[<span class="hljs-number">0</span>] = status;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(tmp);<span class="hljs-comment">//讲byte[]包装成ByteBuffer</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(offset);<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">fc.force(false) 是文件通道（FileChannel）的一个重要方法，主要用于确保数据真正写入磁盘，而不只是停留在操作系统的缓存中。</span><br><span class="hljs-comment">数据写入的流程</span><br><span class="hljs-comment">在向文件写入数据时，操作系统通常会先把数据存储在内存缓存（页缓存）中，之后再择机将数据刷新到磁盘。这种机制虽然能提升性能，但存在数据丢失的风险，比如在系统崩溃或者掉电的情况下，缓存中的数据就可能丢失。</span><br><span class="hljs-comment">force() 方法的作用</span><br><span class="hljs-comment">fc.force(metaData) 方法会强制把通道中尚未写入磁盘的数据刷新到磁盘。这里的参数 metaData 是一个布尔值：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">当 metaData 为 true 时，文件内容和元数据（像文件修改时间、权限等）都会被刷新到磁盘。</span><br><span class="hljs-comment">当 metaData 为 false 时，只会刷新文件内容。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在事务处理中的意义</span><br><span class="hljs-comment">在数据库事务处理系统中，为了保证事务的持久性（D），必须确保事务状态被真正写入磁盘。因此，在更新事务状态后，调用 fc.force(false) 能保证：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">即使系统崩溃，之前记录的事务状态（如已提交、已回滚）也不会丢失。</span><br><span class="hljs-comment">下次系统重启时，可以根据这些持久化的事务状态来恢复数据一致性。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li>开始一个事务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">begin</span><span class="hljs-params">()</span> &#123;<br>        counterLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> xidCounter + <span class="hljs-number">1</span>;<br>            updateXID(xid, FIELD_TRAN_ACTIVE);<br>            incrXIDCounter();<br>            <span class="hljs-keyword">return</span> xid;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            counterLock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面向对象编程知识学习</title>
    <link href="/2025/07/11/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/07/11/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="Java面向对象编程知识学习"><a href="#Java面向对象编程知识学习" class="headerlink" title="Java面向对象编程知识学习"></a>Java面向对象编程知识学习</h2><h3 id="Java三大特性：封装继承多态"><a href="#Java三大特性：封装继承多态" class="headerlink" title="Java三大特性：封装继承多态"></a>Java三大特性：封装继承多态</h3>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2025/07/11/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2025/07/11/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章 </p><img src="/2025/07/11/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/01.png" class="" title="图片引用方法一"> ]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/07/11/hello-world/"/>
    <url>/2025/07/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
